模块使用记录

# CommonJS
主要用在服务器端，Node.js目前使用的规范，使用module.exports或者exports导出，require引入。

> 为了避免出问题，我们一般使用module.exports来导出，因为exports是对module.exports的引用，当你用exports导出的不是一个基本数据类型（JS）,而是一个对象时，那它的引用就会发生改变。

## 基本的用法

- export_test.js
```
let a = 100;
let b = [1, 2, 3];
let c = {
  name: 'lee',
  age: 25
};

function add(a, b) {
  return a + b;
}

module.exports = {
  a,
  b,
  c,
  add
}
```

- import_test.js
```
const obj = require('./export_test.js');

console.log(obj.add(2, 3));  // 5
console.log(obj.a); // 100
```

## 使用exports
这里使用exports的话就要改变一下写法了，前面说过exports是对module.exports的一个引用，你最终导出的还是module.exports，而不是说你写exports导出的就是exports。所以建议在使用时尽量使用module.exports。

- 下面这种写法会报错

> 这个基于上面export_test.js的内容来说的

```
// exports的指向变成了一个包含a,b,c,add的对象，但是CommonJS默认导出的是module.exports，所以require过后也取不到a,b,c,add这些。
exports = {
  a,
  b,
  c,
  add
}
```
- 正确的写法
```
exports.a = a;
exports.b = b;
exports.c = c;
exports.add = add;
```
- 三种正确的导出方法
```
// 三种导出方法，取其中一个即可
/* 第一种导出方法 */
module.exports = {
  a,
  b,
  c,
  add
}

/* 第二种导出方法 */
module.exports.a = a;
module.exports.b = b;
module.exports.c = c;
module.exports.add = add;

/* 第三种导出方法 */
exports.a = a;
exports.b = b;
exports.c = c;
exports.add = add;
```

## 其它注意点

- 混合使用
```
// 混合使用
exports.a = a;
exports.b = b;
module.exports.c = c;
module.exports.add = add;
```
这样也是可以的。

## 特点
CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。

# ES Module
ES Module是ES6提出来的标准，使用export或者export default来导出，使用import来导入。node.js从13.2.0过后开始支持ES Module了，不过把你的js文件命名为mjs，或者在你的项目的package.json中声明`"type": "module"`，我这儿为了方便，更新了node.js为13.5.0，同时文件后缀为mjs。

## 基础用法

- export_test.mjs
```
let a = 100;
let b = [1, 2, 3];
let c = {
  name: 'lee',
  age: 25
};

function add(a, b) {
  return a + b;
}

export {a, b, c, add};
```
- import_test.mjs
```

```